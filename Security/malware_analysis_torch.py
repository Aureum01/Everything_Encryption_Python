# Import the required modules
import torch
import torch.nn as nn
import torch.nn.functional as F

# Build the neural network model
class Model(nn.Module):
  def __init__(self):
    super().__init__()
    self.fc1 = nn.Linear(1024, 128)
    self.fc2 = nn.Linear(128, 64)
    self.fc3 = nn.Linear(64, 1)

  def forward(self, x):
    x = F.relu(self.fc1(x))
    x = F.relu(self.fc2(x))
    x = torch.sigmoid(self.fc3(x))
    return x

model = Model()

# Print a summary of the model architecture
print(model)

# Define a callback function that will be called at the end of each epoch
def on_epoch_end(epoch, logs):
  # Print the current epoch number, training and validation loss and accuracy
  print("Epoch: {}, Training loss: {}, Training accuracy: {}, Validation loss: {}, Validation accuracy: {}".format(
    epoch + 1,
    logs['loss'],
    logs['accuracy'],
    logs['val_loss'],
    logs['val_accuracy']
  ))

# Compile the model
optimizer = torch.optim.Adam(model.parameters())
loss_fn = torch.nn.BCEWithLogitsLoss()

# Train the model, specifying the callback function and the validation split
for epoch in range(10):
  # Compute the training and validation loss and accuracy
  train_loss, train_acc = compute_loss_and_accuracy(model, X_train, y_train)
  val_loss, val_acc = compute_loss_and_accuracy(model, X_val, y_val)

  # Call the callback function
  on_epoch_end(epoch, {
    'loss': train_loss,
    'accuracy': train_acc,
    'val_loss': val_loss,
    'val_accuracy': val_acc
  })

  # Update the model parameters
  optimizer.zero_grad()
  train_loss.backward()
  optimizer.step()

# Evaluate the model
test_loss, test_acc = compute_loss_and_accuracy(model, X_test, y_test)
print("Test loss: {}, Test accuracy: {}".format(test_loss, test_acc))

# Make predictions on the new samples
predictions = model(X_new)

# Count the number of suspicious files
num_suspicious = (predictions > 0.5).sum()

# Print the results
if num_suspicious > 0:
  print("{} suspicious files found.".format(num_suspicious))
else:
  print("No malware spotted.")
